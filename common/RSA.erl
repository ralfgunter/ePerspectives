%% Generated by the Erlang ASN.1 BER_V2-compiler version, utilizing bit-syntax:1.6.13
%% Purpose: encoder and decoder to the types in mod RSA

-module('RSA').
-include("RSA.hrl").
-define('RT_BER',asn1rt_ber_bin_v2).
-asn1_info([{vsn,'1.6.13'},
            {module,'RSA'},
            {options,[ber_bin_v2,optimize,der,compact_bit_string,{i,[46]}]}]).

-export([encoding_rule/0]).
-export([
'enc_WrappedKey'/2,
'enc_RSAPublicKey'/2
]).

-export([
'dec_WrappedKey'/2,
'dec_RSAPublicKey'/2
]).

-export([info/0]).


-export([encode/2,decode/2,encode_disp/2,decode_disp/2]).

encoding_rule() ->
   ber_bin_v2.

encode(Type,Data) ->
case catch encode_disp(Type,Data) of
  {'EXIT',{error,Reason}} ->
    {error,Reason};
  {'EXIT',Reason} ->
    {error,{asn1,Reason}};
  {Bytes,_Len} ->
    {ok,Bytes};
  Bytes ->
    {ok,Bytes}
end.

decode(Type,Data) ->
case catch decode_disp(Type,element(1,?RT_BER:decode(Data))
) of
  {'EXIT',{error,Reason}} ->
    {error,Reason};
  {'EXIT',Reason} ->
    {error,{asn1,Reason}};
  Result ->
    {ok,Result}
end.

encode_disp('WrappedKey',Data) -> 'enc_WrappedKey'(Data);
encode_disp('RSAPublicKey',Data) -> 'enc_RSAPublicKey'(Data);
encode_disp(Type,_Data) -> exit({error,{asn1,{undefined_type,Type}}}).


decode_disp('WrappedKey',Data) -> 'dec_WrappedKey'(Data);
decode_disp('RSAPublicKey',Data) -> 'dec_RSAPublicKey'(Data);
decode_disp(Type,_Data) -> exit({error,{asn1,{undefined_type,Type}}}).





info() ->
   case ?MODULE:module_info() of
      MI when is_list(MI) ->
         case lists:keysearch(attributes,1,MI) of
            {value,{_,Attributes}} when is_list(Attributes) ->
               case lists:keysearch(asn1_info,1,Attributes) of
                  {value,{_,Info}} when is_list(Info) ->
                     Info;
                  _ ->
                     []
               end;
            _ ->
               []
         end
   end.


%%================================
%%  WrappedKey
%%================================
'enc_WrappedKey'(Val) ->
    'enc_WrappedKey'(Val, [<<48>>]).

'enc_WrappedKey'(Val, TagIn) ->
{_,Cindex1, Cindex2} = Val,

%%-------------------------------------------------
%% attribute seq(1) with type SEQUENCE
%%-------------------------------------------------
   {EncBytes1,EncLen1} = 'enc_WrappedKey_seq'(Cindex1, [<<48>>]),

%%-------------------------------------------------
%% attribute publicKey(2) with type BIT STRING
%%-------------------------------------------------
   {EncBytes2,EncLen2} = ?RT_BER:encode_bit_string([], Cindex2, [], [<<3>>]),

   BytesSoFar = [EncBytes1, EncBytes2],
LenSoFar = EncLen1 + EncLen2,
?RT_BER:encode_tags(TagIn, BytesSoFar, LenSoFar).



%%================================
%%  WrappedKey_seq
%%================================
'enc_WrappedKey_seq'(Val, TagIn) ->
   {_,Cindex1, Cindex2} = Val,

%%-------------------------------------------------
%% attribute rsaIdentifier(1) with type OBJECT IDENTIFIER
%%-------------------------------------------------
   {EncBytes1,EncLen1} = ?RT_BER:encode_object_identifier(Cindex1, [<<6>>]),

%%-------------------------------------------------
%% attribute null(2) with type NULL
%%-------------------------------------------------
   {EncBytes2,EncLen2} = ?RT_BER:encode_null(Cindex2, [<<5>>]),

   BytesSoFar = [EncBytes1, EncBytes2],
LenSoFar = EncLen1 + EncLen2,
?RT_BER:encode_tags(TagIn, BytesSoFar, LenSoFar).
'dec_WrappedKey_seq'(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = ?RT_BER:match_tags(Tlv,TagIn), 

%%-------------------------------------------------
%% attribute rsaIdentifier(1) with type OBJECT IDENTIFIER
%%-------------------------------------------------
[V1|Tlv2] = Tlv1, 
Term1 = ?RT_BER:decode_object_identifier(V1,[6]),

%%-------------------------------------------------
%% attribute null(2) with type NULL
%%-------------------------------------------------
[V2|Tlv3] = Tlv2, 
Term2 = ?RT_BER:decode_null(V2,[5]),

case Tlv3 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv3}}}) % extra fields not allowed
end,
   {'WrappedKey_seq', Term1, Term2}.



'dec_WrappedKey'(Tlv) ->
   'dec_WrappedKey'(Tlv, [16]).

'dec_WrappedKey'(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = ?RT_BER:match_tags(Tlv,TagIn), 

%%-------------------------------------------------
%% attribute seq(1) with type SEQUENCE
%%-------------------------------------------------
[V1|Tlv2] = Tlv1, 
Term1 = 'dec_WrappedKey_seq'(V1, [16]),

%%-------------------------------------------------
%% attribute publicKey(2) with type BIT STRING
%%-------------------------------------------------
[V2|Tlv3] = Tlv2, 
Term2 = ?RT_BER:decode_compact_bit_string(V2,[],[],[3]),

case Tlv3 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv3}}}) % extra fields not allowed
end,
   {'WrappedKey', Term1, Term2}.



%%================================
%%  RSAPublicKey
%%================================
'enc_RSAPublicKey'(Val) ->
    'enc_RSAPublicKey'(Val, [<<48>>]).

'enc_RSAPublicKey'(Val, TagIn) ->
{_,Cindex1, Cindex2} = Val,

%%-------------------------------------------------
%% attribute modulus(1) with type INTEGER
%%-------------------------------------------------
   {EncBytes1,EncLen1} = ?RT_BER:encode_integer([], Cindex1, [<<2>>]),

%%-------------------------------------------------
%% attribute publicExponent(2) with type INTEGER
%%-------------------------------------------------
   {EncBytes2,EncLen2} = ?RT_BER:encode_integer([], Cindex2, [<<2>>]),

   BytesSoFar = [EncBytes1, EncBytes2],
LenSoFar = EncLen1 + EncLen2,
?RT_BER:encode_tags(TagIn, BytesSoFar, LenSoFar).


'dec_RSAPublicKey'(Tlv) ->
   'dec_RSAPublicKey'(Tlv, [16]).

'dec_RSAPublicKey'(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = ?RT_BER:match_tags(Tlv,TagIn), 

%%-------------------------------------------------
%% attribute modulus(1) with type INTEGER
%%-------------------------------------------------
[V1|Tlv2] = Tlv1, 
Term1 = ?RT_BER:decode_integer(V1,[],[2]),

%%-------------------------------------------------
%% attribute publicExponent(2) with type INTEGER
%%-------------------------------------------------
[V2|Tlv3] = Tlv2, 
Term2 = ?RT_BER:decode_integer(V2,[],[2]),

case Tlv3 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv3}}}) % extra fields not allowed
end,
   {'RSAPublicKey', Term1, Term2}.

